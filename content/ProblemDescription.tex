\chapter{Problem Description}
\label{chapter:ProblemDescription}

The \ac{cpg} implementation we extend currently has no means of providing information about the structure and contents of string variables that go beyond propagating literals if they are not changed.

Describing such strings is not trivial, as often at least part of a given string stems from an unknown source, for example runtime user input.

We solve this issue by first describing a given string with a formal grammar, which conservatively approximates the values the string can take.
This means that for a string $s$, the language generated by the grammar we obtain to describe $s$, always contains all possible values $s$ can have.

We want to use regular expressions as a final representation, because they are human-readable and therefore allow users to manually evaluate our results for a security analysis.

Since the generated grammars are context free, they generate context free languages, which are a superset of the regular languages accepted by regular expressions. Therefore we can't directly convert the obtained grammars to regular expressions, but rather need to approximate them into grammars that generate regular languages first.

This approximation poses the challenge that we need to decide, which information to retain and which parts to change. We also need to account for the effects of operations like a \lstinline|replace| function on the analyzed strings. We also need to ensure that our approximation stays conservative.

Furthermore, we need to convert the obtained grammars to equivalent regular expressions. Since the grammars our approximation creates are not textbook regular grammars, but strongly regular grammars, we need to use algorithms suited to this type of grammar for the conversion.

Since we use automata as an intermediary step in the conversion from grammar to regular expression, we use the state elimination algorithm \cite{brzozowksi_mccluskey} to convert a \ac{nfa} to a regular expression. As we want our results to be human-readable, we need to minimize the length of the resulting regular expression by optimizing the state elimination algorithm.

\begin{comment}
	
The introduction is a bit like a teaser. Here, you dig more into details, also
technical ones. After this chapter, the reader must understand why you do this
work, why it's important, what makes it difficult and what you want to achieve.

\begin{itemize}
\item What's the problem that you're trying to solve?
\item What is your goal?
\item What is/are the research question(s)?
\item What are special problems?
\end{itemize}

Probably 1-3 pages

\end{comment}
